"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6533],{16964:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>o});var t=s(86106),r=s(82036);const i={id:"helpers",title:"Helpers",sidebar_position:5},l=void 0,d={id:"api-reference/helpers",title:"Helpers",description:"connectField",source:"@site/versioned_docs/version-4.0/api-reference/helpers.mdx",sourceDirName:"api-reference",slug:"/api-reference/helpers",permalink:"/docs/api-reference/helpers",draft:!1,unlisted:!1,tags:[],version:"4.0",sidebarPosition:5,frontMatter:{id:"helpers",title:"Helpers",sidebar_position:5},sidebar:"docs",previous:{title:"Context data",permalink:"/docs/api-reference/context-data"}},c={},o=[{value:"<code>connectField</code>",id:"connectfield",level:2},{value:"Field kinds",id:"field-kinds",level:3},{value:"Props merging order",id:"props-merging-order",level:3},{value:"<code>changedKeys</code>",id:"changedkeys",level:2},{value:"<code>filterDOMProps</code>",id:"filterdomprops",level:2},{value:"Custom props registration",id:"custom-props-registration",level:3},{value:"<code>joinName</code>",id:"joinname",level:2},{value:"<code>randomIds</code>",id:"randomids",level:2},{value:"<code>useForm</code>",id:"useform",level:2},{value:"<code>useField</code>",id:"usefield",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"connectfield",children:(0,t.jsx)(n.code,{children:"connectField"})}),"\n",(0,t.jsxs)(n.p,{children:["Provides form management related props. The ",(0,t.jsx)(n.code,{children:"connectField"})," helper is a component wrapper (higher order component, HOC), that provides various props related to the form management. It also adds the ",(0,t.jsx)(n.code,{children:"Field"})," suffix to the name of the wrapped component."]}),"\n",(0,t.jsxs)(n.p,{children:["The table below lists all of the ",(0,t.jsx)(n.strong,{children:"guaranteed"})," props that will be passed to the wrapped component:"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Name"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Type"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"changed"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Has field changed?"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"disabled"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Is field disabled?"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"error"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"object"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Field scoped part of validation error."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"errorMessage"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Field scoped validation error message."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"field"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"object"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Field definition from schema."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"fields"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"arrayOf(string)"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Subfields names."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"fieldType"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"func"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Field type."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"id"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Field id - given or random."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"label"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Field label."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"name"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Field name."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"onChange"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"func(value, [name])"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Change field value."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"placeholder"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Field placeholder."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"readOnly"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Is field read-only?"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"showInlineError"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Show inline error?"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"value"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"any"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Field value."})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"connectField"})," function accepts two arguments: the first one is a component and the second one is an ",(0,t.jsx)(n.code,{children:"options"})," object."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"function Example(props) {\n  /* ... */\n}\n\nconst ExampleField = connectField(Example, options);\n"})}),"\n",(0,t.jsx)(n.p,{children:"The table below lists all available options:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Name"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Type"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"initialValue"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsxs)(n.td,{style:{textAlign:"center"},children:["Initial value check. If ",(0,t.jsx)(n.code,{children:"true"}),", then after the first render the default value is set as value if no value is provided (",(0,t.jsx)(n.code,{children:"undefined"}),")."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"kind"})}),(0,t.jsxs)(n.td,{style:{textAlign:"center"},children:[(0,t.jsx)(n.code,{children:"'leaf'"})," or ",(0,t.jsx)(n.code,{children:"'node'"})]}),(0,t.jsxs)(n.td,{style:{textAlign:"center"},children:["See ",(0,t.jsx)(n.a,{href:"#field-kinds",children:"Field kinds"}),"."]})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"field-kinds",children:"Field kinds"}),"\n",(0,t.jsxs)(n.p,{children:["Every field is either a ",(0,t.jsx)(n.em,{children:"leaf"})," or ",(0,t.jsx)(n.em,{children:"node"})," field. In the future, we could introduce new kinds to enable even more optimizations."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Leaf"})," fields cannot have subfields. This allows us to perform some optimizations, like skipping the extra ",(0,t.jsx)(n.code,{children:"Provider"})," from ",(0,t.jsx)(n.code,{children:"connectField"}),", effectively reducing the overhead down to a single ",(0,t.jsx)(n.code,{children:"useField"})," call.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["It includes all input fields, like ",(0,t.jsx)(n.code,{children:"NumField"}),", ",(0,t.jsx)(n.code,{children:"SelectField"})," or ",(0,t.jsx)(n.code,{children:"TextField"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Node"})," fields can have subfields. Fields of the ",(0,t.jsx)(n.em,{children:"leaf"})," kind cannot have subfields.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["It includes all combined and layout fields, like ",(0,t.jsx)(n.code,{children:"ListField"})," or ",(0,t.jsx)(n.code,{children:"NestField"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you are not sure which one to use, do not use the ",(0,t.jsx)(n.code,{children:"kind"})," option at all - it'll default to the safest option (right now it's ",(0,t.jsx)(n.code,{children:"node"}),")."]}),"\n",(0,t.jsx)(n.h3,{id:"props-merging-order",children:"Props merging order"}),"\n",(0,t.jsxs)(n.p,{children:["The resulting props of a field are a merge of the props that uniforms provide, the ones coming from the bridge (schema) and finally the actual field props. For the exact ordering, please refer to the ",(0,t.jsxs)(n.a,{href:"https://github.com/vazco/uniforms/blob/master/packages/uniforms/src/useField.tsx",children:["source of ",(0,t.jsx)(n.code,{children:"useField"})," hook"]}),". Overall, it looks as follows:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["uniforms props (e.g., ",(0,t.jsx)(n.code,{children:"changed"}),", ",(0,t.jsx)(n.code,{children:"onChange"}),", ",(0,t.jsx)(n.code,{children:"value"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["uniforms state (as defined in ",(0,t.jsx)(n.a,{href:"/docs/api-reference/context-data/#state",children:"context data"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"bridge props (depending on the schema)"}),"\n",(0,t.jsx)(n.li,{children:"field props (only when rendered directly)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["That's important, as using empty values in the schema or field props, like ",(0,t.jsx)(n.code,{children:"undefined"}),", will be merged as well. See ",(0,t.jsx)(n.a,{href:"https://github.com/vazco/uniforms/issues/1094",children:"#1094"})," for more context as well as an example of a potential pitfall."]}),"\n",(0,t.jsx)(n.h2,{id:"changedkeys",children:(0,t.jsx)(n.code,{children:"changedKeys"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns an array of changed keys between ",(0,t.jsx)(n.code,{children:"valueA"})," and ",(0,t.jsx)(n.code,{children:"valueB"}),", where ",(0,t.jsx)(n.code,{children:"root"})," is the root key. For examples see ",(0,t.jsxs)(n.a,{href:"https://github.com/vazco/uniforms/blob/master/packages/uniforms/__tests__/changedKeys.ts",children:[(0,t.jsx)(n.code,{children:"changedKeys"})," tests"]}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { changedKeys } from 'uniforms';\n\nchangedKeys('a', { b: 1, c: 2 }, { b: 1 }); // ['a', 'a.c']\n"})}),"\n",(0,t.jsx)(n.h2,{id:"filterdomprops",children:(0,t.jsx)(n.code,{children:"filterDOMProps"})}),"\n",(0,t.jsxs)(n.p,{children:["Removes all uniforms-related props, registered with ",(0,t.jsx)(n.code,{children:"filterDOMProps.register"}),". Use it in all places where you'd like to pass all unrelated props down and ",(0,t.jsx)(n.code,{children:"useField"})," or ",(0,t.jsx)(n.code,{children:"connectField"})," provide you with the props."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { filterDOMProps } from 'uniforms';\n\nconst filteredProps = filterDOMProps(props);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"custom-props-registration",children:"Custom props registration"}),"\n",(0,t.jsxs)(n.p,{children:["It's often the case that your custom components will have a bunch of known properties, like ",(0,t.jsx)(n.code,{children:"locale"})," or ",(0,t.jsx)(n.code,{children:"userType"}),". To ease the process of using them across the project, you can register them to make ",(0,t.jsx)(n.code,{children:"filterDOMProps"})," remove them as well. For example, ",(0,t.jsx)(n.a,{href:"https://github.com/vazco/uniforms/blob/master/packages/uniforms-bridge-simple-schema/src/register.ts",children:(0,t.jsx)(n.code,{children:"SimpleSchemaBridge"})})," registers all of the SimpleSchema-specific options."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { filterDOMProps } from 'uniforms';\n\nfilterDOMProps({ example: 42 }); // { example: 42 }\nfilterDOMProps.registered.includes('example'); // false\nfilterDOMProps.register('example');\nfilterDOMProps.registered.includes('example'); // true\nfilterDOMProps({ example: 42 }); // {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As ",(0,t.jsx)(n.code,{children:"filterDOMProps"})," is fully typed, if you'd like to make it work with TypeScript, you have to extend the ",(0,t.jsx)(n.code,{children:"FilterDOMProps"})," interface as well."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"declare module 'uniforms' {\n  interface FilterDOMProps {\n    propA: never;\n    propB: never;\n  }\n}\n\nfilterDOMProps.register('propA', 'propB');\n"})}),"\n",(0,t.jsx)(n.h2,{id:"joinname",children:(0,t.jsx)(n.code,{children:"joinName"})}),"\n",(0,t.jsxs)(n.p,{children:["Safely joins partial field names.\nIf you create a custom field with subfields, do use ",(0,t.jsx)(n.code,{children:"joinName"})," instead of manually concatenating them.\nIt ensures that the name will be correctly escaped if needed."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { joinName } from 'uniforms';\n\njoinName('array', 1, 'field'); // 'array.1.field'\njoinName('object', 'nested.property'); // 'object.nested.property'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If the first argument is ",(0,t.jsx)(n.code,{children:"null"}),", then it returns an array of escaped parts."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { joinName } from 'uniforms';\n\njoinName(null, 'array', 1, 'field'); // ['array', '1', 'field']\njoinName(null, 'object', 'nested.property'); // ['object', 'nested', 'property']\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If the field name contains a dot (",(0,t.jsx)(n.code,{children:"."}),") or a bracket (",(0,t.jsx)(n.code,{children:"["})," or ",(0,t.jsx)(n.code,{children:"]"}),"), it has to be escaped with ",(0,t.jsx)(n.code,{children:'["..."]'}),".\nIf any of these characters is not escaped, ",(0,t.jsx)(n.code,{children:"joinName"})," will ",(0,t.jsx)(n.strong,{children:"not"})," throw an error but its behavior is not specified.\nThe escape of any other name part will be stripped."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"joinName(null, 'object[\"with.dot\"].field'); // ['object', '[\"with.dot\"]', 'field']\njoinName('object[\"with.dot\"].field'); // 'object[\"with.dot\"].field'\n\njoinName(null, 'this[\"is\"].safe'); // ['this', 'is', 'safe']\njoinName('this[\"is\"].safe'); // 'this.is.safe'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For more examples check ",(0,t.jsxs)(n.a,{href:"https://github.com/vazco/uniforms/blob/master/packages/uniforms/__tests__/joinName.ts",children:[(0,t.jsx)(n.code,{children:"joinName"})," tests"]}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"randomids",children:(0,t.jsx)(n.code,{children:"randomIds"})}),"\n",(0,t.jsxs)(n.p,{children:["Generates random ID, based on given prefix. Use it, if you want to have random but deterministic strings. If no prefix is provided, a unique ",(0,t.jsx)(n.code,{children:"uniforms-X"})," prefix will be used generated."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { randomIds } from 'uniforms';\n\nconst randomId1 = randomIds();\nrandomId1(); // uniforms-0000-0000\nrandomId1(); // uniforms-0000-0001\nrandomId1(); // uniforms-0000-0002\n\nconst randomId2 = randomIds();\nrandomId2(); // uniforms-0001-0000\nrandomId2(); // uniforms-0001-0001\nrandomId2(); // uniforms-0001-0002\n\nconst randomId3 = randomIds('prefix');\nrandomId3(); // prefix-0000\nrandomId3(); // prefix-0001\nrandomId3(); // prefix-0002\n"})}),"\n",(0,t.jsx)(n.h2,{id:"useform",children:(0,t.jsx)(n.code,{children:"useForm"})}),"\n",(0,t.jsxs)(n.p,{children:["A direct way of accessing the ",(0,t.jsx)(n.a,{href:"/docs/api-reference/context-data/#state",children:"context data"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useForm } from 'uniforms';\n\nfunction Example() {\n  const context = useForm();\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"usefield",children:(0,t.jsx)(n.code,{children:"useField"})}),"\n",(0,t.jsxs)(n.p,{children:["A hook version of ",(0,t.jsx)(n.a,{href:"#connectfield",children:(0,t.jsx)(n.code,{children:"connectField"})}),". It receives three arguments: field name (",(0,t.jsx)(n.code,{children:"string"}),"), field props (",(0,t.jsx)(n.code,{children:"object"}),"), and optional options."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"function Example(props) {\n  const [fieldProps, context] = useField(props.name, props, options);\n  return <input {...filterDOMProps(fieldProps)} />;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The table below lists all available options:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Name"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Type"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Default"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"absoluteName"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"false"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"Whether the field name should be treated as a top-level one, ignoring parent fields."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"initialValue"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"true"})}),(0,t.jsxs)(n.td,{style:{textAlign:"center"},children:["Initial value check. If ",(0,t.jsx)(n.code,{children:"true"}),", then after the first render the default value is set as value if no value is provided (",(0,t.jsx)(n.code,{children:"undefined"}),")."]})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Using ",(0,t.jsx)(n.code,{children:"useField"})," allows you to create components that combine values of multiple fields:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useField } from 'uniforms';\n\nfunction ArePasswordsEqual() {\n  const [{ value: passwordA }] = useField('passwordA', {});\n  const [{ value: passwordB }] = useField('passwordB', {});\n  const areEqual = passwordA === passwordB;\n  return <div>{`Passwords are ${areEqual ? 'equal' : 'not equal'}`}</div>;\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},82036:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var t=s(7378);const r={},i=t.createContext(r);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);